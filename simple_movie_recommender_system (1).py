# -*- coding: utf-8 -*-
"""Simple movie recommender System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AH0oSBVLcsfVH72pSaGFZ5r3anR6C_GT

# Movie Recommender System

Recommender systems are now one of the most effective drivers of digital business traffic. In terms of movies, they provide and easy route for personal satisfaction for customers while increasing viewership. In this project, we build a simple recommender system using correlation matrix.

The data from this project is extracted from the TMDB database.
"""

# Commented out IPython magic to ensure Python compatibility.
# Import all necessary libraries
import numpy as np  # For numerical operations
import pandas as pd  # For handling data in dataframes
import matplotlib.pyplot as plt  # For plotting graphs
import seaborn as sns  # For high-level interface for drawing attractive statistical graphics

sns.set_style('white')  # Set the visual style of the plots to 'white'
# %matplotlib inline  # This magic function ensures that matplotlib graphs are displayed inline within Jupyter Notebooks

#Get the data into Pandas Dataframe object
column_names = ['user_id', 'item_id', 'rating', 'timestamp']
df = pd.read_csv('dataset.csv', sep = '\t', names = column_names)
df.head()

"""**Overview of Operation:**

The snippet in question guides through the steps of importing a dataset into a Pandas DataFrame, crucial for further data manipulation and analysis. This action initializes the data exploration phase by assigning user-defined column names and showcasing a segment of the dataset for initial review.

**Step-by-Step Breakdown:**

- Column Labeling: By creating a list named column_names, each element aligns with a dataset column, thus establishing a clear and meaningful reference for future data operations.
- Data Importing: Utilizing pd.read_csv(), the function is tailored with sep='\t' to adapt to a tab-delimited format, ensuring precise data structuring.
The incorporation of names=column_names maps the established names directly to the dataset columns, fortifying the dataset's readability and usability.
- Initial Data View: Executing df.head() serves as a swift validation technique to ensure data integrity and correct loading. Displaying the first five rows offers a snapshot of the dataset, enabling an immediate preliminary check.

**Context and Applications:**
- The method demonstrated is typical of early stages in data science workflows, particularly suited for scenarios where structured data exploration is about to commence.
- It confirms that the dataset's fundamental structure aligns with analytical expectations.
"""

#Get the Movie Titles
movie_titles = pd.read_csv('TMDB_movies.csv')
movie_titles.head()

"""**Action Overview:**

This segment of code is designed to import a dataset containing movie titles into a DataFrame, enabling quick access and manipulation of the data relevant to movie analytics.

**Process Breakdown:**

- Import Command: movie_titles = pd.read_csv('TMDB_movies.csv') loads the dataset from the file named 'TMDB_movies.csv', which is presumed to contain movie-related data, directly into a DataFrame called movie_titles. This method is straightforward and utilizes Pandasâ€™ powerful data handling capabilities.
- Previewing Data: The command movie_titles.head() is executed to display the first five entries of the DataFrame. This is a conventional method to quickly inspect the initial rows of the dataset to confirm its structure and content.

**Utility and Application:**

- Immediate Use: Loading and previewing data in this manner is standard practice in data science, particularly useful when starting the exploration of a new dataset. It allows for a quick assessment of data formatting, availability of key information, and any obvious issues that might need addressing.

Then the ratings
"""

#Merge the dataset with movie titles
df = pd.merge(df, movie_titles, on = 'item_id')
df.head()

"""**Operation Summary:** The code merges two distinct datasets: one containing user interaction data and the other containing detailed movie titles, using a common key.

**Detailed Walkthrough:**

- Merging Mechanism: The pd.merge() function is used to combine df and movie_titles based on the 'item_id' column, which is common to both DataFrames. This operation aligns rows from both DataFrames wherever there is a match in their 'item_id' values.
- Execution of Merge: The result of this merge is reassigned to df, updating it to include columns from both the original user-item interactions and the movie titles data. The merge type defaults to an inner join, meaning only pairs with matching 'item_id' are retained.
- Initial Display: Post-merge, df.head() is called to display the top five rows of the newly merged DataFrame. This is an essential step to verify that the merge was successful and to visually confirm that the DataFrame now contains combined data from both sources.

**Implications and Usage:**

- Data Enrichment: This merge operation effectively enriches the interaction data with corresponding movie details, which can be critical for tasks requiring comprehensive data, such as content-based filtering or detailed data analysis.

Next, we perform some Exploratory Data Analysis
"""

df.groupby('title')['rating'].mean().sort_values(ascending = False).head()

"""**Core Action:** This command aggregates user ratings by movie titles and identifies the highest-rated films based on average scores.

**Step-by-Step Explanation:**

- Grouping Data: df.groupby('title') groups the DataFrame by the 'title' column, collecting all entries for each unique movie title into separate subsets. This operation is foundational for any subsequent aggregation specific to each movie.
- Calculating Averages: ['rating'].mean() computes the mean of the 'rating' column for each group, yielding the average rating per movie. This step quantifies the overall approval or disapproval of movies by users.
Sorting Results: sort_values(ascending = False) sorts these averages in descending order, placing movies with the highest average ratings at the top of the list. This ordering method is crucial for quickly identifying top-rated content.
- Displaying Top Entries: head() then limits the output to the first five entries, which are the movies with the highest average ratings. This function is particularly useful for snapshot insights and presentations.

**Significance and Applications:**

- Insight Extraction: This analysis is vital for uncovering standout movies in a dataset, which can be useful for recommendations, marketing strategies, and content curation.
"""

df.groupby('title')['rating'].count().sort_values(ascending = False).head()

"""**Principal Operation:**

This segment of code aims to quantify and rank movies based on the volume of user ratings they've received, providing a clear picture of which titles have garnered the most viewer interaction.

**Detailed Breakdown:**

- Data Grouping: By applying df.groupby('title'), the DataFrame is organized into groups where each group consists of data for a unique movie title. This grouping is essential for performing specific calculations on a per-movie basis.
- Rating Counts: Within each group, ['rating'].count() calculates the total number of ratings, effectively measuring user engagement for each title. This metric is crucial as a higher count of ratings often implies greater popularity or viewer interest.
- Ordering Results: The sort_values(ascending = False) method sorts these counts in descending order, ensuring that movies with the most ratings appear first. This sorting helps in quickly identifying the most popular or most viewed movies in the dataset.
- Limiting Output: Finally, head() is called to restrict the output to the top five entries. This function is used to focus on the most relevant data, in this case, the movies with the highest number of ratings.

**Strategic Insights and Usage:**

- Utility in Content Strategy: Understanding which movies attract the most ratings can inform content strategies, including decisions about promotions, acquisitions, or removals from a catalog based on viewer engagement levels.
"""

ratings = pd.DataFrame(df.groupby('title')['rating'].mean())
ratings.head()

"""**Action Initiated:**

This piece of code calculates the average ratings for each movie and consolidates these averages into a new DataFrame, providing a focused view on how each title is rated on average by users.

**Detailed Steps:**

- Calculating Averages: Using df.groupby('title')['rating'].mean(), the DataFrame df is grouped by the column 'title', and the mean (average) of the 'rating' column for each group is calculated. This operation transforms the raw ratings into meaningful averages that reflect the overall user sentiment towards each movie.
- Creating DataFrame: The result of the grouping and mean calculation is passed into pd.DataFrame(), effectively creating a new DataFrame named ratings. This DataFrame is structured with movie titles as the index and their corresponding average ratings as the data.
- Preview of Results: The ratings.head() function is used to display the first five rows of the new DataFrame. This is a standard method to quickly check the top part of the DataFrame, ensuring that the data has been structured as intended and to get a glimpse of the output.

**Usage Insight:**

- Simplifying Data Analysis: By transforming the raw ratings into averages per title and storing these in a separate DataFrame, the code simplifies further analysis related to average ratings, making it easier to query, sort, and visualize the data.
"""

ratings['numOfRatings'] = pd.DataFrame(df.groupby('title')['rating'].count())
ratings.head()

"""**Key Operation:**

Enhancing the ratings DataFrame by appending a column that reflects the count of ratings per movie title, providing a fuller picture of viewer engagement along with the average rating data.

**Operational Details:**

- Counting Ratings: The expression df.groupby('title')['rating'].count() groups the original df DataFrame by movie title and then counts the number of ratings for each title. This method quantifies how many times users have rated each movie, offering insights into the popularity and user interaction levels.
- Adding Column: The result of the counting operation is then assigned to a new column in the ratings DataFrame named numOfRatings. This integrates direct numerical feedback data into the DataFrame that previously held only the average ratings, making the ratings table more informative and robust.
- Previewing Enhanced Data: ratings.head() displays the first five rows of the updated DataFrame, allowing for a quick verification to ensure that the new column has been added correctly and to view the initial data.

**Strategic Insights and Practical Usage:**

- Comprehensive Data Analysis: The updated DataFrame now serves as a more comprehensive dataset for analysis, combining both qualitative (average rating) and quantitative (number of ratings) aspects. This dual data setup is particularly useful for assessing not just how highly movies are rated but also how broadly they are viewed and reviewed.
"""

plt.figure(figsize = (10,4))
ratings['numOfRatings'].hist(bins = 70)

"""**Analysis of the Histogram**

- Skewed Distribution: The histogram shows a highly right-skewed distribution. This indicates that a large number of movies have a relatively small number of ratings, while a few movies have a very high number of ratings.

- Dominance of Few Titles: The tall bar at the leftmost part of the histogram (near zero) suggests that the majority of movies receive only a small number of ratings. This can imply that many movies in your dataset are not as popular or well-known among viewers.

- Long Tail: The long tail extending towards the right indicates that there are movies with a wide range of higher rating counts, though these are significantly fewer. Movies falling into this part of the distribution might be blockbusters or highly popular films that attract much larger audiences.

**Quantitative Insights:**

- Most Populated Bins: The bins between 0 and 100 contain the majority of the data points, suggesting that most movies receive between 1 to 100 ratings.
Sparse Higher Rating Counts: As the number of ratings increases beyond 100, the frequency of movies receiving that many ratings decreases sharply, as shown by the decreasing height of the bars towards the right.


**Strategic Implications**
- Focus on Popular Movies: The data suggests that attention might be concentrated on the few movies that receive a lot of ratings. These movies could be leveraged for promotional activities or to draw traffic to a streaming platform.

- Potential for Niche Marketing: The large number of movies with few ratings might represent niche genres or lesser-known films. There could be an opportunity to target specific audience segments interested in these types of films.

- Content Acquisition Strategies: For a streaming service, this distribution could inform content acquisition strategiesâ€”focusing on obtaining rights to both highly rated popular films to satisfy mainstream demand and a selection of niche films to cater to varied tastes.
"""

plt.figure(figsize = (10,4))
ratings['rating'].hist(bins = 70)

"""**Interpretation of the Histogram**

- Wide Range of Ratings: The histogram covers the full spectrum of possible ratings from 1.0 to 5.0, indicating a diverse array of movie qualities within the dataset.
- Peak Distributions: There's a prominent peak around the 3.0 to 3.5 rating range. This suggests that a significant number of movies have average ratings within this mid-range, indicating that many movies are considered average by viewers.

**Notable Trends:**
- High Frequency of Mid-Range Ratings: The concentration of bars in the 2.5 to 4.0 range is quite high compared to the lower and higher ends of the rating spectrum. This might suggest that users tend to give moderate ratings more frequently than very low or high ratings.
- Drop-offs at Extremes: There are noticeable drop-offs at the lower end (below 2.0) and the higher end (above 4.5), with fewer movies receiving these extreme ratings. This could indicate that viewers are generally reserved in their highest praise and harshest criticism.

**Strategic Insights**
- Content Analysis: The clustering of ratings around the middle suggests a potential for content improvement or targeted promotion to enhance viewer satisfaction. Movies that are in the higher end of the average range (close to 4.0) could be highlighted in promotions to attract viewers seeking quality content.
- Viewer Engagement: The distribution shows that viewers do not often rate movies at the extremes, which might reflect a level of engagement or a tendency to avoid extreme judgments unless strongly provoked by content quality.
"""

sns.jointplot(x='rating', y='numOfRatings', data = ratings, alpha = 0.5)

"""**Analysis of the Jointplot**

**Scatter Plot Analysis:**

- Distribution Pattern: The scatter plot shows a dense concentration of points at the lower end of the rating scale with fewer ratings, and a spread that widens as the ratings increase, peaking around a rating of 4.0. This indicates that movies with higher ratings tend to have more ratings, possibly suggesting that better-rated movies attract more viewers or that viewers are more inclined to rate movies they like.
- Correlation: There appears to be a moderate positive correlation between the number of ratings a movie receives and its average rating. This could imply that movies that are well-liked tend to receive more attention and ratings from the audience.

**Histogram Analysis (Margins):**

- Top Histogram (Ratings): The histogram above the scatter plot shows a distribution with a mode around 3.5 to 4.0, indicating that most movies have average ratings in this range. There's also a noticeable decline in frequency as the rating approaches both the lower and higher ends of the scale.
- Right Histogram (Number of Ratings): The histogram to the right displays a steep drop-off in the frequency of movies as the number of ratings increases. This suggests that while a few movies get a high number of ratings, the majority receive far fewer, consistent with a long-tail distribution typical in user-based reviews.

**Strategic Implications**
- Focus on Quality and Engagement: The visual data suggests that increasing the quality of movies could lead to higher engagement in terms of ratings. This might inform strategies around content creation, acquisition, and promotion, focusing on quality to boost viewer engagement and satisfaction.
- Marketing and Promotion: Movies within the higher average rating brackets, particularly those receiving numerous ratings, can be marketed more aggressively as top choices to attract viewers looking for quality content. Conversely, movies with fewer ratings but high average scores might be hidden gems that could benefit from increased visibility.

### Create the Recommendation System

Create a matrix that has the user ids on one access and the movie title on another axis. Each cell will then consist of the rating the user gave to that movie. Note there will be a lot of NaN values, because most people have not seen most of the movies.
"""

moviemat = df.pivot_table(index='user_id',columns='title',values='rating')
moviemat.head()

"""**Essential Function:**

This segment of code constructs a user-item interaction matrix, crucial for many recommendation systems and exploratory data analyses in media consumption.

**Process Unpacked:**

- Pivot Table Creation: The pivot_table method is employed to reorganize the original DataFrame. Specifying index='user_id' sets user IDs as the row labels, columns='title' assigns movie titles as the column headers, and values='rating' fills the matrix with the ratings each user has given to each movie.
- Matrix Structure: The resultant matrix, stored in moviemat, provides a comprehensive view where each row corresponds to a user's ratings across all movies, and each column represents all users' ratings for a particular movie. Cells are filled with ratings, and likely NaN (not a number) where a user has not rated a particular title.

**Visualization of Initial Data:**

- moviemat.head(): This function call displays the first five rows of the newly formed pivot table. This initial peek is vital for verifying the transformation's accuracyâ€”ensuring that the matrix has correctly populated according to the specified dimensions and values.

**Strategic Insights and Usage:**

- Data Structure for Recommendation Systems: This kind of matrix is particularly well-suited for collaborative filtering techniques, where algorithms predict a user's rating for an unrated item based on ratings from similar users or similar items.
- Exploratory Data Analysis: Analysts can quickly identify which movies are most and least rated, examine user engagement levels, and detect common patterns or anomalies in movie ratings.
"""

#Most Rated Movies with their Average Ratings
ratings.sort_values('numOfRatings', ascending = False).head(10)

"""**Primary Objective:**

To identify the movies that have attracted the most viewer interaction, indicated by the number of ratings they have received, and to review their average ratings for a comprehensive understanding of their reception.

**Execution Breakdown:**

- Sorting Operation: The sort_values method is applied to the ratings DataFrame, specifically targeting the 'numOfRatings' column. By setting ascending = False, the DataFrame is sorted in descending order, placing movies with the highest number of ratings at the top.
- Display Top Entries: The head(10) function limits the output to the top 10 entries. This truncation is particularly useful for focusing attention on the most significant data pointsâ€”here, the 10 most rated movies.

**Insight Extraction:**

- Viewer Engagement: This listing provides immediate insight into which movies have captured the most attention from the audience. High numbers of ratings generally indicate strong viewer engagement, whether due to popularity, quality, or controversy.
- Quality Assessment: Alongside the engagement data, the average ratings offer a measure of how much these movies are liked on average, which can be crucial for understanding their overall reception.

**Strategic Implications:**

- Content Strategy: For media companies and streaming platforms, understanding which movies garner the most ratings can guide decisions related to content licensing, promotions, and recommendations.
- Marketing Initiatives: Highlighting popular movies in marketing campaigns can leverage existing viewer interest to attract new subscribers or re-engage current users.

Now we will create a correlation matrix of every movie with every other movie on user ratings. We will then use that correlation matrix to find top matches that relates the best for a particular movie (having atleast 100 ratings) and the result obtained (recommended movies) will then be added to the ratings dataframe of every movie. Those whose matches could not be obtained using correlation, their value will be converted to "-".
"""

for i in ratings.index:
    movieUserRatings = moviemat[i]
    similarToThatMovie = moviemat.corrwith(movieUserRatings)
    corr_toMovie = pd.DataFrame(similarToThatMovie, columns = ['Correlation'])
    corr_toMovie.dropna(inplace = True)
    corr_toMovie = corr_toMovie.join(ratings['numOfRatings'])
    result = corr_toMovie[corr_toMovie['numOfRatings'] > 100].sort_values('Correlation', ascending = False).head()
    if result['numOfRatings'].count() >= 5:
        print(i)
        ratings.loc[i, 'FirstMovieRecommendation'] = result.iloc[1:2].index.values[0]
        ratings.loc[i, 'SecondMovieRecommendation'] = result.iloc[2:3].index.values[0]
        ratings.loc[i, 'ThirdMovieRecommendation'] = result.iloc[3:4].index.values[0]
        ratings.loc[i, 'FourthMovieRecommendation'] = result.iloc[4:5].index.values[0]

"""**Overview of the Code Operation**

This script aims to enhance the ratings DataFrame by adding columns for recommended movies. These recommendations are derived based on how similar other movies' user ratings patterns are to each specific movie.

**Detailed Step-by-Step Breakdown**

**Iterating Over Movies:**

The for loop iterates through each movie title in the ratings index.
movieUserRatings retrieves the user ratings for the current movie from the moviemat pivot table, which contains user ratings for all movies.

**Calculating Correlations:**

- similarToThatMovie = moviemat.corrwith(movieUserRatings) computes the Pearson correlation coefficient between the user ratings for the current movie and all other movies in the moviemat matrix. This step identifies movies with similar rating patterns.
- The results are stored in a DataFrame corr_toMovie, focusing on the correlation values.

**Cleaning and Joining Data:**

- corr_toMovie.dropna(inplace=True) removes any entries without correlation data, ensuring the dataset is clean.
The corr_toMovie is then joined with ratings['numOfRatings'] to add the number of ratings for each movie, providing context to the correlation values.

**Filtering and Sorting Recommendations:**

- The movies are filtered to include only those with more than 100 ratings (corr_toMovie['numOfRatings'] > 100), focusing on widely-rated movies to ensure the recommendations are based on robust data.
- The results are sorted by 'Correlation' in descending order to prioritize the most similar movies.

**Selecting Top Recommendations:**

- The code checks if there are at least 5 movies that meet the criteria, then it prints the current movie and records the top recommendations excluding the first (most correlated entry, likely the movie itself) for the subsequent top movies.

**Insights and Strategic Implications**
- Enhanced User Experience: By integrating a recommendation feature based on movie similarities, platforms can significantly improve user engagement and satisfaction.
- Data-Driven Recommendations: This method ensures that suggestions are backed by user behavior data, enhancing the relevance and personalization of the recommendations.
"""

#Check the result
ratings.head()

ratings = ratings.fillna('-')

#Save the ratings data for later use
ratings.to_csv('MovieRecommendations.csv', encoding='utf-8')

